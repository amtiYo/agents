import type { ResolvedMcpServer } from '../types.js'

function escapeToml(value: string): string {
  return value.replaceAll('\\', '\\\\').replaceAll('"', '\\"')
}

function quoteTomlKey(key: string): string {
  return `"${escapeToml(key)}"`
}

export interface RenderResult {
  content: string
  warnings: string[]
}

export function renderCodexToml(servers: ResolvedMcpServer[]): RenderResult {
  const warnings: string[] = []
  const lines: string[] = ['# Generated by agents sync. Do not edit manually.', '']

  for (const server of servers) {
    lines.push(`[mcp_servers.${quoteTomlKey(server.name)}]`)

    if (server.transport === 'stdio') {
      if (!server.command) {
        warnings.push(`Server "${server.name}" has no command; skipped in Codex output.`)
        lines.pop()
        continue
      }
      lines.push(`command = "${escapeToml(server.command)}"`)
      lines.push(
        `args = [${(server.args ?? []).map((arg) => `"${escapeToml(arg)}"`).join(', ')}]`,
      )
    } else {
      if (!server.url) {
        warnings.push(`Server "${server.name}" has no url; skipped in Codex output.`)
        lines.pop()
        continue
      }
      if (server.transport === 'sse') {
        warnings.push(`Server "${server.name}" uses legacy sse transport; rendering as URL for Codex compatibility.`)
      }
      lines.push(`url = "${escapeToml(server.url)}"`)
    }

    lines.push('enabled = true')
    lines.push('autoApprove = []')
    lines.push('')

    if (server.env && Object.keys(server.env).length > 0) {
      lines.push(`[mcp_servers.${quoteTomlKey(server.name)}.env]`)
      for (const key of Object.keys(server.env).sort()) {
        lines.push(`${quoteTomlKey(key)} = "${escapeToml(server.env[key])}"`)
      }
      lines.push('')
    }

    if (server.headers && Object.keys(server.headers).length > 0) {
      lines.push(`[mcp_servers.${quoteTomlKey(server.name)}.http_headers]`)
      for (const key of Object.keys(server.headers).sort()) {
        lines.push(`${quoteTomlKey(key)} = "${escapeToml(server.headers[key])}"`)
      }
      lines.push('')
    }
  }

  return {
    content: `${lines.join('\n')}\n`,
    warnings
  }
}

export function renderGeminiServers(servers: ResolvedMcpServer[]): {
  mcpServers: Record<string, unknown>
  warnings: string[]
} {
  const warnings: string[] = []
  const out: Record<string, unknown> = {}

  for (const server of servers) {
    if (server.transport === 'stdio') {
      if (!server.command) {
        warnings.push(`Server "${server.name}" has no command; skipped in Gemini output.`)
        continue
      }
      out[server.name] = {
        type: 'stdio',
        command: server.command,
        args: server.args ?? [],
        ...(server.env ? { env: server.env } : {})
      }
      continue
    }

    if (!server.url) {
      warnings.push(`Server "${server.name}" has no url; skipped in Gemini output.`)
      continue
    }
    out[server.name] = {
      type: server.transport,
      url: server.url,
      ...(server.headers ? { headers: server.headers } : {})
    }
  }

  return { mcpServers: out, warnings }
}

export function renderVscodeMcp(servers: ResolvedMcpServer[]): {
  servers: Record<string, unknown>
  warnings: string[]
} {
  const warnings: string[] = []
  const out: Record<string, unknown> = {}

  for (const server of servers) {
    if (server.transport === 'stdio') {
      if (!server.command) {
        warnings.push(`Server "${server.name}" has no command; skipped in VS Code MCP output.`)
        continue
      }
      out[server.name] = {
        type: 'stdio',
        command: server.command,
        args: server.args ?? [],
        ...(server.env ? { env: server.env } : {})
      }
      continue
    }

    if (!server.url) {
      warnings.push(`Server "${server.name}" has no url; skipped in VS Code MCP output.`)
      continue
    }
    out[server.name] = {
      type: server.transport,
      url: server.url,
      ...(server.headers ? { headers: server.headers } : {})
    }
  }

  return { servers: out, warnings }
}

export function renderWindsurfMcp(servers: ResolvedMcpServer[]): {
  mcpServers: Record<string, unknown>
  warnings: string[]
} {
  const warnings: string[] = []
  const out: Record<string, unknown> = {}

  for (const server of servers) {
    if (server.transport === 'stdio') {
      if (!server.command) {
        warnings.push(`Server "${server.name}" has no command; skipped in Windsurf output.`)
        continue
      }
      out[server.name] = {
        command: server.command,
        args: server.args ?? [],
        ...(server.env ? { env: server.env } : {})
      }
      continue
    }

    if (!server.url) {
      warnings.push(`Server "${server.name}" has no url; skipped in Windsurf output.`)
      continue
    }
    out[server.name] = {
      serverUrl: server.url,
      ...(server.headers ? { headers: server.headers } : {})
    }
  }

  return { mcpServers: out, warnings }
}

export function renderOpencodeMcp(servers: ResolvedMcpServer[]): {
  mcp: Record<string, unknown>
  warnings: string[]
} {
  const warnings: string[] = []
  const out: Record<string, unknown> = {}

  for (const server of servers) {
    if (server.transport === 'stdio') {
      if (!server.command) {
        warnings.push(`Server "${server.name}" has no command; skipped in OpenCode output.`)
        continue
      }
      out[server.name] = {
        type: 'local',
        enabled: true,
        command: [server.command, ...(server.args ?? [])],
        ...(server.env ? { environment: server.env } : {})
      }
      continue
    }

    if (!server.url) {
      warnings.push(`Server "${server.name}" has no url; skipped in OpenCode output.`)
      continue
    }
    out[server.name] = {
      type: 'remote',
      enabled: true,
      url: server.url,
      ...(server.headers ? { headers: server.headers } : {})
    }
  }

  return { mcp: out, warnings }
}
