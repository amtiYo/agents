import type { ResolvedMcpServer } from '../types.js'

function escapeToml(value: string): string {
  return value.replaceAll('\\', '\\\\').replaceAll('"', '\\"')
}

function quoteTomlKey(key: string): string {
  return `"${escapeToml(key)}"`
}

export interface RenderResult {
  content: string
  warnings: string[]
}

export function renderCodexToml(servers: ResolvedMcpServer[]): RenderResult {
  const warnings: string[] = []
  const lines: string[] = ['# Generated by agents sync. Do not edit manually.', '']

  for (const server of servers) {
    if (server.transport !== 'stdio') {
      warnings.push(`Codex does not support non-stdio server "${server.name}" in file mode; skipped.`)
      continue
    }
    if (!server.command) {
      warnings.push(`Server "${server.name}" has no command; skipped in Codex output.`)
      continue
    }

    lines.push(`[mcp_servers.${quoteTomlKey(server.name)}]`)
    lines.push(`command = "${escapeToml(server.command)}"`)
    lines.push(
      `args = [${(server.args ?? []).map((arg) => `"${escapeToml(arg)}"`).join(', ')}]`,
    )
    lines.push('enabled = true')
    lines.push('autoApprove = []')
    lines.push('')

    if (server.env && Object.keys(server.env).length > 0) {
      lines.push(`[mcp_servers.${quoteTomlKey(server.name)}.env]`)
      for (const key of Object.keys(server.env).sort()) {
        lines.push(`${key} = "${escapeToml(server.env[key])}"`)
      }
      lines.push('')
    }
  }

  return {
    content: `${lines.join('\n')}\n`,
    warnings
  }
}

export function renderGeminiServers(servers: ResolvedMcpServer[]): {
  mcpServers: Record<string, unknown>
  warnings: string[]
} {
  const warnings: string[] = []
  const out: Record<string, unknown> = {}

  for (const server of servers) {
    if (server.transport === 'stdio') {
      if (!server.command) {
        warnings.push(`Server "${server.name}" has no command; skipped in Gemini output.`)
        continue
      }
      out[server.name] = {
        type: 'stdio',
        command: server.command,
        args: server.args ?? [],
        ...(server.env ? { env: server.env } : {})
      }
      continue
    }

    if (!server.url) {
      warnings.push(`Server "${server.name}" has no url; skipped in Gemini output.`)
      continue
    }
    out[server.name] = {
      type: server.transport,
      url: server.url,
      ...(server.headers ? { headers: server.headers } : {})
    }
  }

  return { mcpServers: out, warnings }
}

export function renderVscodeMcp(servers: ResolvedMcpServer[]): {
  servers: Record<string, unknown>
  warnings: string[]
} {
  const warnings: string[] = []
  const out: Record<string, unknown> = {}

  for (const server of servers) {
    if (server.transport === 'stdio') {
      if (!server.command) {
        warnings.push(`Server "${server.name}" has no command; skipped in VS Code MCP output.`)
        continue
      }
      out[server.name] = {
        type: 'stdio',
        command: server.command,
        args: server.args ?? [],
        ...(server.env ? { env: server.env } : {})
      }
      continue
    }

    if (!server.url) {
      warnings.push(`Server "${server.name}" has no url; skipped in VS Code MCP output.`)
      continue
    }
    out[server.name] = {
      type: server.transport,
      url: server.url,
      ...(server.headers ? { headers: server.headers } : {})
    }
  }

  return { servers: out, warnings }
}
